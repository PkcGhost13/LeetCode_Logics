
**LeetCode Link:** https://leetcode.com/problems/longest-common-prefix/

This note summarizes common approaches to the "Longest Common Prefix" problem, with Java examples, time/space complexity, pros/cons, and edge-case notes.

Problem summary

- Given an array of strings, return the longest common prefix shared among all strings. If there is no common prefix, return an empty string.

Implementations

- Prefix-shrinking using `indexOf` (provided solution)

	This approach starts with the first string as the candidate prefix and iteratively shortens it until it becomes a prefix of every other string. It uses `String#indexOf(prefix) == 0` to check whether a string starts with the current prefix; if not, the prefix is truncated by one character and rechecked.

	```java
	class Solution {
		public String longestCommonPrefix(String[] strs) {
			if (strs == null || strs.length == 0) {
				return "";
			}
			String prefix = strs[0];
			for (int i = 1; i < strs.length; i++) {
				while (strs[i].indexOf(prefix) != 0) {
					prefix = prefix.substring(0, prefix.length() - 1);
				}
				if (prefix.isEmpty()) {
					return "";
				}
			}
			return prefix;
		}
	}
	```

	Type: Horizontal scanning with progressive prefix shrinking (uses `indexOf` to test prefix).

	Time complexity (worst-case): O(n * m^2), where n is number of strings and m is the length of the initial prefix (roughly the length of `strs[0]`). Reason: for each of the (n-1) strings, the algorithm may call `indexOf` up to O(m) times while shrinking the prefix one character at a time, and each `indexOf` can take O(m) time in the worst-case, yielding O(m^2) per string.

	Average/practical behavior: often much better than worst-case because `indexOf` may succeed early and the prefix typically shrinks quickly.

	Space complexity: O(1) auxiliary (plus O(m) for the `prefix` string). Note: each `substring` call allocates a new String, so the algorithm generates temporary strings; this causes extra allocation overhead (transient memory) which may be non-trivial when `m` is large.

	Pros:
	- Simple to understand and implement.
	- Uses Java's built-in `indexOf` check rather than manual char comparisons.

	Cons:
	- Potentially inefficient due to repeated `indexOf` calls and substring allocations, leading to worst-case quadratic behavior.
	- Creates many temporary String objects (garbage/allocations) because `substring` copies characters.

	When to use:
	- Acceptable for small inputs or when `strs[0]` is short. Prefer vertical/horizontal scanning without repeated substring allocations for large inputs.


- Vertical scanning (character-by-character)

	Compare characters column-wise across all strings.
	```java
	class Solution {
		public String longestCommonPrefix(String[] strs) {
			if (strs == null || strs.length == 0) return "";
			for (int i = 0; i < strs[0].length(); i++) {
				char c = strs[0].charAt(i);
				for (int j = 1; j < strs.length; j++) {
					if (i == strs[j].length() || strs[j].charAt(i) != c) {
						return strs[0].substring(0, i);
					}
				}
			}
			return strs[0];
		}
	}
	```

	Complexity: Time O(S) where S is the sum of all characters in all strings (worst-case you examine every char). Space O(1) (ignoring output).

	Pros:
	- Simple and easy to implement.
	- Stops early as soon as mismatch occurs.

	Cons:
	- If strings share long prefixes, still scans many characters.

---
- Horizontal scanning (pairwise prefix reduction)

	Iteratively compute LCP of prefix and next string.
	```java
	class Solution {
		private String commonPrefix(String s1, String s2) {
			int min = Math.min(s1.length(), s2.length());
			int i = 0;
			while (i < min && s1.charAt(i) == s2.charAt(i)) i++;
			return s1.substring(0, i);
		}

		public String longestCommonPrefix(String[] strs) {
			if (strs == null || strs.length == 0) return "";
			String prefix = strs[0];
			for (int i = 1; i < strs.length; i++) {
				prefix = commonPrefix(prefix, strs[i]);
				if (prefix.isEmpty()) return "";
			}
			return prefix;
		}
	}
	```

	Complexity: Time O(S), Space O(1) (not counting output). Works well when prefixes shrink quickly.

	Pros:
	- Good when prefix rapidly reduces; avoids scanning full matrix.

	Cons:
	- Still can approach O(S) in worst case.

---
- Divide and conquer

	Split array into halves, compute LCP for each half, then merge.

	Complexity: Time O(S), Space O(m) recursion overhead where m = log n recursion depth, plus temporary substrings.

	Pros:
	- Parallelizable; elegant recursion.

	Cons:
	- More code and recursion overhead.

---
- Binary search on prefix length

	Binary search the length L (0..minLength) and check whether all strings share prefix of length L.

	Complexity: Time O(S log m) where m is min string length and S is work for checking each length (checking all strings up to length L each time). Space O(1).

	Pros:
	- Useful when strings are long but prefix length is small; reduces number of character comparisons.

	Cons:
	- More complex; checking step repeats work across iterations.

---
- Sorting-based (compare first and last)

	Sort the array lexicographically, then LCP of first and last string is LCP of whole array.

	Complexity: Time O(n log n * k) where k is average comparison cost (or O(n log n * m)), Space O(n) depending on sort.

	Pros:
	- Very simple idea; only need to compare two strings after sort.

	Cons:
	- Sorting overhead makes it worse for large n; not optimal if only LCP is needed.

---
- Trie (prefix tree)

	Build a trie of all strings, then walk from root while single-child nodes and not terminal.

	Complexity: Time O(S) to build and traverse, Space O(S) for trie nodes.

	Pros:
	- Powerful when reusing structure for repeated queries; supports additional prefix queries.

	Cons:
	- Heavyweight for a single LCP query due to memory and implementation complexity.

Edge-cases and notes

- Empty array: return empty string.
- Single string: return the string itself.
- Strings containing empty string: LCP is empty string.
- Unicode / multi-byte characters: Java `char` is UTF-16 code unit; for full Unicode codepoint correctness use codepoint-aware iteration if needed.
- Performance: vertical/horizontal/divide-and-conquer are typically best in practice for this problem.

Complexity summary

- Vertical scanning: Time O(S), Space O(1).
- Horizontal scanning: Time O(S), Space O(1).
- Divide and conquer: Time O(S), Space O(log n) recursion overhead.
- Binary search (on length): Time O(S log m), Space O(1).
- Sorting-based: Time O(n log n * k), Space O(n).
- Trie: Time O(S), Space O(S).

Which to choose

- For typical use choose vertical or horizontal scanning for simplest, clear O(S) behavior.
- Use binary search if you expect extremely long strings but short prefix lengths and you want to reduce comparisons across repeated long strings.
- Use trie only when you need prefix structure for multiple different queries.

