# 1. Two Sum

**Leetcode Link: https://leetcode.com/problems/two-sum/**

This note summarizes common Two Sum implementations, their time/space complexity, and pros/cons.

**Implementations**

- **Brute Force (double loop)**

    Simple nested loops checking every pair.
    ```java
    class Solution {
        public int[] twoSum(int[] nums, int target) {
            for (int i = 0; i < nums.length; i++) {
                for (int j = i + 1; j < nums.length; j++) {
                    if (nums[i] + nums[j] == target) {
                        return new int[]{i, j};
                    }
                }
            }
            return null; // or throw depending on contract
        }
    }
    ```

    Complexity: Time O(n^2), Space O(1).

    Pros:
    - Very simple to implement and reason about.
    - No extra data structures required.

    Cons:
    - Not practical for large arrays due to quadratic time.

---
- **HashMap (one-pass, complement map)**

    Use a map to record seen values and their indices while scanning once.
    ```java
    class Solution {
        public int[] twoSum(int[] nums, int target) {
            Map<Integer, Integer> seen = new HashMap<>();
            for (int i = 0; i < nums.length; i++) {
                int complement = target - nums[i];
                if (seen.containsKey(complement)) {
                    return new int[]{seen.get(complement), i};
                }
                seen.put(nums[i], i);
            }
            return null;
        }
    }
    ```

    Complexity: Average time O(n), Space O(n). (Worst-case time can degrade if hashing is pathological.)

    Pros:
    - Fast and the typical LeetCode solution.
    - Single pass and returns original indices.

    Cons:
    - Uses additional O(n) memory.

---
- **Two-pointer after sorting (value-index pairs)**

    Sort a list of (value, originalIndex) pairs, then use two pointers to find the sum. Return the stored original indices.
    ```java
    class Solution {
        public int[] twoSum(int[] nums, int target) {
            int n = nums.length;
            int[][] pairs = new int[n][2];
            for (int i = 0; i < n; i++) { 
	            pairs[i][0] = nums[i]; pairs[i][1] = i; 
	         }
            Arrays.sort(pairs, Comparator.comparingInt(a -> a[0]));
            int l = 0, r = n - 1;
            while (l < r) {
                int sum = pairs[l][0] + pairs[r][0];
                if (sum == target) return new int[]{pairs[l][1], pairs[r][1]};
                if (sum < target) l++; else r--;
            }
            return null;
        }
    }
    ```

    Complexity: Time O(n log n) due to sort, Space O(n) if storing pairs (or O(1) auxiliary if you sort in place but then you'd lose original indices).

    Pros:
    - Useful when constant extra memory is desired apart from pair storage and you can tolerate sorting.
    - Simple two-pointer scan after sort.

    Cons:
    - Sorting changes the element order; you must track original indices.
    - Slower than the hashmap approach for large n because of the sort.

---
- **Binary search per element (sort + binary search)**

    Sort values with indices, then for each element do binary search for complement. Complexity also O(n log n).

    Complexity: Time O(n log n), Space O(n).

    Pros:
    - Deterministic complexity; uses well-known algorithms.

    Cons:
    - More code and similar performance to the two-pointer approach.

---

**Other notes and edge-cases**

- LeetCode contract: usually guarantees exactly one solution â€” you can return immediately when found. If not guaranteed, return an empty result or throw as needed.
- Integer overflow: adding two ints could overflow; if inputs may be large, consider using `long` for sums in languages that require it.
- Duplicate values: the hashmap approach stores one index per value; it still works because you check complement before inserting the current value (handles cases like target = 6, nums = [3,3]).
- HashMap worst-case: pathological hash collisions can degrade performance to O(n^2), but this is uncommon with Java's built-in hashing.

**Complexity summary**

- Brute Force: Time O(n^2), Space O(1).
- HashMap (one-pass): Average Time O(n), Space O(n).
- Sort + Two-pointer: Time O(n log n), Space O(n) (to keep original indices).
- Sort + Binary search: Time O(n log n), Space O(n).

**Which to choose**

- Use the one-pass HashMap in most practical scenarios for best average performance and simplicity.
- Use sort + two-pointer when you prefer less reliance on hashing or when you need the result in sorted order by value (but remember to keep indices).
- Use brute-force only for tiny inputs, tests, or when simplicity is paramount.



